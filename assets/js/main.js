// Generated by CoffeeScript 1.8.0
var add_creature, add_money, buy_creature, callbacks, check_for_new_game, clear_creatures, currAttack, currentFight, currentQuestion, data, data_, e, fight_attack, fight_attack_tooltip, fight_change_vals, fight_check_question, fight_enemy_attack, fight_parse_inline_vars, fight_question, fight_start, get_JSON, init, isInArray, load_attacks, load_creatures, load_questions_english, load_questions_french, load_questions_latin, load_story, money, notify, open_shop, owned_creatures, parse_inline_vars, parse_story, parse_story_element, play_sound, pop, random, reset, reset_test, set_active_creature, set_character, set_name, set_storyline, shop_dialog, show_choose_creature, skip_tut, update_money, update_shop;

isInArray = function(value, array) {
  return array.indexOf(value) > -1;
};

document.addEventListener("polymer-ready", function() {
  var drawerPanel, navicon;
  navicon = document.getElementById("navicon");
  drawerPanel = document.getElementById("drawerPanel");
  navicon.addEventListener("click", function() {
    drawerPanel.togglePanel();
  });
  init();
});

data = {};

data_ = {};

callbacks = {};

currentFight = 'noFightRunning';

currentQuestion = {};

currAttack = {};

try {
  console.log("Init soundcloud");
  SC.initialize({
    client_id: "bb72e01542b2481b1ed0c625951bcb03"
  });
} catch (_error) {
  e = _error;
  console.log("soundcloud failed");
}

play_sound = function(sound_id) {
  try {
    SC.stream(sound_id, function(sound) {
      return sound.play();
    });
  } catch (_error) {
    e = _error;
    console.log("You probably don't have any or a good network connection");
  }
  localStorage.story_pos = parseInt(localStorage.story_pos) + 1;
  return parse_story();
};

callbacks = {
  log_hey: function() {
    return console.log("Hey");
  }
};

$("#dialog_choose_name").on("change", function() {
  return set_name();
});

get_JSON = function(what, where) {
  data_ = void 0;
  return $.getJSON("assets/data/" + what + ".json", function(json) {
    data_ = json;
    return data[where] = data_;
  });
};

load_story = function() {
  console.log("loading story");
  return $.getJSON("assets/data/" + localStorage.storyline + "-story.json", function(json) {
    data.story = json;
    return load_attacks();
  });
};

load_questions_latin = function() {
  console.log("loading latin questions");
  data.questions = {};
  return $.getJSON("assets/data/latin-questions.json", function(json) {
    return data.questions.latin = json;
  });
};

load_questions_english = function() {
  console.log("loading english questions");
  return $.getJSON("assets/data/english-questions.json", function(json) {
    return data.questions.english = json;
  });
};

load_questions_french = function() {
  console.log("loading french questions");
  return $.getJSON("assets/data/french-questions.json", function(json) {
    return data.questions.french = json;
  });
};

load_attacks = function() {
  console.log("loading attacks");
  return $.getJSON("assets/data/attacks.json", function(json) {
    data.attacks = json;
    return load_creatures();
  });
};

load_creatures = function() {
  console.log("Hey I am loading the creatures");
  return $.getJSON("assets/data/creatures.json", function(json) {
    data.creatures = json;
    load_questions_latin();
    load_questions_english();
    load_questions_french();
    return parse_story();
  });
};

reset = function() {
  localStorage.clear();
  return window.location.reload();
};

reset_test = function() {
  localStorage.clear();
  return window.location.replace("/");
};

random = function(from, to) {
  var res;
  console.log("from: " + from);
  console.log("to: " + to);
  res = Math.floor((Math.random() * to) + from);
  console.log("number: " + res);
  return res;
};

shop_dialog = $('.shop')[0];

add_creature = function(creature) {
  if (localStorage.ownedCreatures === '') {
    localStorage.ownedCreatures += creature;
  } else {
    localStorage.ownedCreatures += '||' + creature;
  }
  return owned_creatures();
};

add_money = function(number) {
  localStorage.money = money() + number;
  return update_money();
};

buy_creature = function(creature) {
  if (money() >= data.creatures[creature].basestats.price) {
    console.log('You bought ' + creature);
    add_creature(creature);
    return add_money(-data.creatures[creature].basestats.price);
  } else {
    return console.log('You dont have enough money to buy ' + creature);
  }
};

clear_creatures = function() {
  return localStorage.ownedCreatures = '';
};

money = function() {
  return parseInt(localStorage.money);
};

open_shop = function() {
  update_shop();
  return shop_dialog.toggle();
};

owned_creatures = function() {
  return localStorage.ownedCreatures.split('||');
};

set_active_creature = function(creature) {
  return localStorage.character = creature;
};

update_money = function() {
  return $('.money_count').html(money());
};

update_shop = function() {
  var key, __append__, __attacks__, __button_action__, __button_class__, __button_text__, __creature__, __disabled__, __health__, __type__, _ref, _results;
  $('.shop').html('<h1 class="shop-h1">Shop</h1><p>Welcome to the shop. Here you can buy more creatures. You will need to answer questions according to the type of your active creature. Be careful when buying new creatures, because you don\'t know how strong they are.</p>');
  _ref = data.creatures;
  _results = [];
  for (key in _ref) {
    __creature__ = _ref[key];
    if (!data.creatures.hasOwnProperty(key)) {
      continue;
    }
    __creature__ = data.creatures[key];
    __disabled__ = '';
    __health__ = __creature__.basestats.hp;
    __type__ = '';
    __attacks__ = __creature__.attacks;
    __button_class__ = '';
    __button_text__ = '';
    __button_action__ = '';
    if (localStorage.character === key) {
      __button_class__ = 'active';
      __button_text__ = 'ACTIVE';
      __button_action__ = 'console.log("already active")';
    } else if (isInArray(key, owned_creatures())) {
      __button_class__ = 'select';
      __button_text__ = 'SELECT';
      __button_action__ = "set_active_creature(\"" + key + "\")";
    } else {
      __button_class__ = 'buy';
      __button_text__ = __creature__.basestats.price + ':money_with_wings:';
      __button_action__ = "buy_creature(\"" + key + "\")";
      if (__creature__.basestats.price > money() || __creature__.basestats.price === void 0) {
        __disabled__ = 'disabled';
      }
    }
    if (__creature__.basestats.type.toLowerCase() === 'latin') {
      __type__ = ':it:';
    } else if (__creature__.basestats.type.toLowerCase() === 'english') {
      __type__ = ':gb:';
    } else if (__creature__.basestats.type.toLowerCase() === 'french') {
      __type__ = ':fr:';
    }
    __append__ = "<div class='card'> <h3>" + key + "</h3> <span class='block'>HEALTH: " + __health__ + "</span> <span class='block'>TYPE: " + __type__ + "</span> <span class='block'>ATTACKS:</span> <ul> <li>" + __attacks__[0] + "</li> <li>" + __attacks__[1] + "</li> <li>" + __attacks__[2] + "</li> </ul> <paper-button class='" + __button_class__ + "' onclick='" + __button_action__ + "; update_shop()' " + __disabled__ + ">" + __button_text__ + "</paper-button> </div>";
    if (__creature__.basestats.buy !== false) {
      $('.shop').append(__append__);
    }
    _results.push(emojify.run());
  }
  return _results;
};

function Fight (enemy, enemy_lvl) {
	this.character = localStorage.character;
	this.player_lvl = parseInt(localStorage.lvl);
	this.enemy = enemy;
	this.enemy_lvl = enemy_lvl;

	this.player_description = data.creatures[this.character].description;
	this.enemy_description = data.creatures[this.enemy].description;

	//Keeps track of health
	this.player_health = Math.round(parseInt(data.creatures[this.character].basestats.hp) * parseInt(localStorage.lvl) / 33);
	this.enemy_health = Math.round(parseInt(data.creatures[this.enemy].basestats.hp) * parseInt(enemy_lvl) / 33);
	this.player_basehealth = this.player_health;
	this.enemy_basehealth = this.enemy_health;
	$(".player-basehealth").html(this.player_basehealth)
	$(".enemy-basehealth").html(this.enemy_basehealth)

	//Keeps track type and multipliers and attacks
	this.player_type = data.creatures[this.character].basestats.type;
	this.enemy_type = data.creatures[this.enemy].basestats.type;

	this.player_attack_multiplier = 1.0;
	this.enemy_attack_multiplier = 1.0;
	this.player_defense_multiplier = 1.0;
	this.enemy_defense_multiplier = 1.0 ;

	this.player_attacks = data.creatures[this.character].attacks;
	this.enemy_attacks = data.creatures[this.enemy].attacks;

	//keeps track of whos turn it is
	this.turn = 'player';
	this.victim = 'enemy';
	this.ended = false;

	this.switch_turn = function () {

		if (this.ended) {
			console.log("fight is over");
			console.log(this.ended);
			return
		}

		console.log("running switch_turn");
		console.log("currentFight.turn was " + this.turn);
		if (this.turn == 'player') {
			this.turn = 'enemy';
			this.victim = 'player';
			$(".select_attack > .attack_btns > paper-button").attr("disabled", "");
			fight_enemy_attack();
		} else {
			this.turn = 'player';
			this.victim  = 'enemy';
			$(".select_attack > .attack_btns > paper-button").removeAttr("disabled");
		}
		console.log("currentFight.turn is now " + this.turn);
	};

	this.update_health = function () {
		$(".fight_area > .creatures > .player > paper-progress").attr("value", Math.round(this.player_health / this.player_basehealth * 100));
		$(".fight_area > .creatures > .enemy > paper-progress").attr("value", Math.round(this.enemy_health / this.enemy_basehealth * 100));
		$(".player-health").html()
		$(".player-health").html(this.player_health)
		$(".enemy-health").html(this.enemy_health)

	};

	this.set_display = function () {
		//setting h1 with names and lvl of creatures and tooltips
		$('.fight_area > .creatures > .player > h1 > core-tooltip > span.name').html(this.character);
		$('.fight_area > .creatures > .enemy > h1 > core-tooltip > span.name').html(this.enemy);
		$('.fight_area > .creatures > .player > h1 > span.lvl > span').html(this.player_lvl);
		$('.fight_area > .creatures > .enemy > h1 > span.lvl > span').html(this.enemy_lvl);
		$('.fight_area > .creatures > .player > h1 > core-tooltip').attr("label", this.player_description);
		$('.fight_area > .creatures > .enemy > h1 > core-tooltip').attr("label", this.enemy_description);

		//Attack btns
		$(".select_attack > .attack_btns").html("");
		for (var i = 0; i < this.player_attacks.length; i++) {
			// console.log("Testing " + i + " (" + this.player_attacks[i] + ") and it is:");
			// console.log(data.attacks[this.player_attacks[i]]);
			$(".select_attack > .attack_btns").append(
				"<core-tooltip class='" + i + "' position='top'>"+
					"<paper-button raised onclick='fight_question(\""+ this.player_attacks[i]+ "\")'>" + this.player_attacks[i] + "</paper-button>"+
					"<div tip class='tip'>"+
					"</div>"+
				"</core-tooltip>"
			);
			var tt_self = false;
			var tt_other = false;
			var tt_dat = {}
			if (data.attacks[this.player_attacks[i]].hasOwnProperty("action-self")) {
				console.log("has self");
				tt_self = true;
				tt_dat.self_type = data.attacks[this.player_attacks[i]]["action-self"][0]
				tt_dat.self_val = data.attacks[this.player_attacks[i]]["action-self"][1]
				console.log("self_type: " + tt_dat.self_type);
				console.log("self_val: " + tt_dat.self_val);

			}
			if (data.attacks[this.player_attacks[i]].hasOwnProperty("action")) {
				tt_other = true;
				tt_dat.other_type = data.attacks[this.player_attacks[i]].action[0]
				tt_dat.other_val = data.attacks[this.player_attacks[i]].action[1]
			}
			fight_attack_tooltip(tt_self, tt_other, tt_dat, i)
		}

		this.check_health = function () {
			if (this.player_health <= 0) {
				swal({
					title: "You lost the Battle.",
					text: "Try again!",
					type: "error"
				},
					function () {
						parse_story();
					}
				);
				this.ended = true;
			} else if (this.enemy_health <= 0) {
				swal({
					title: "You won the Battle!",
					text: "You earn one level. Continue you journey.",
					type: "success"
				},
					function () {
						localStorage.story_pos = parseInt(localStorage.story_pos) + 1;
						localStorage.lvl = parseInt(localStorage.lvl) + 1;
						parse_story();
						$(".fight_area").fadeOut("fast");
					});
				this.ended = true;
			}
		};

		this.update_health();
	};
};

fight_start = function(enemy, enemy_lvl) {
  console.log("running fight_start");
  currentFight = new Fight(enemy, enemy_lvl);
  currentFight.set_display();
  return $(".fight_area").fadeIn("fast");
};

fight_question = function(attack_name) {
  var i, _i, _len, _ref;
  console.log("running fight_question");
  currentQuestion.difficulty = data.attacks[attack_name].difficulty;
  currentQuestion.question = data.questions[data.attacks[attack_name].type][currentQuestion.difficulty][random(0, data.questions[data.attacks[attack_name].type][currentQuestion.difficulty].length)];
  if (currentQuestion.question.hasOwnProperty('right')) {
    $(".dialog").html("<paper-dialog backdrop heading='" + currentQuestion.question.question + "' class='paper-dialog-transition paper-dialog-transition-bottom' transition='paper-dialog-transition-bottom'> <h3>Answer this question to perform the attack!</h3> <paper-radio-group class='radio-gr'></paper-radio-group> <paper-button onclick='fight_check_question(\"" + attack_name + "\")' autofocus role='button' affirmative>Attack!</paper-button> </paper-dialog>");
    _ref = currentQuestion.question.answer;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      $('.radio-gr').append('<paper-radio-button name="' + currentQuestion.question.answer.indexOf(i) + '" label="' + i + '"></paper-radio-button>');
    }
  } else {
    $(".dialog").html("<paper-dialog backdrop heading='" + currentQuestion.question.question + "' class='paper-dialog-transition paper-dialog-transition-bottom' transition='paper-dialog-transition-bottom'> <h3>Answer this question to perform the attack!</h3> <paper-input autoclosedisabled label='enter your answer here'></paper-input> <paper-button onclick='fight_check_question(\"" + attack_name + "\")' autofocus role='button' affirmative>Attack!</paper-button> </paper-dialog>");
  }
  return $(".dialog > paper-dialog")[0].toggle();
};

fight_check_question = function(attack_name) {
  var i, __lower_array, __success__, _i, _ref;
  __success__ = false;
  console.log("running fight_check_question");
  __lower_array = [];
  for (i = _i = 0, _ref = currentQuestion.question.answer.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
    __lower_array.push(currentQuestion.question.answer[i].toLowerCase());
  }
  try {
    $(".core-overlay-backdrop").remove();
  } catch (_error) {}
  if (localStorage.cheatMode === "Boss" || localStorage.character === 'Ben-Cheat') {
    __success__ = true;
  }
  if (currentQuestion.question.hasOwnProperty('right')) {
    if (parseInt($('.radio-gr')[0].selected) === currentQuestion.question.right) {
      __success__ = true;
    }
  } else {
    if ($(".dialog > paper-dialog > paper-input").val().toLowerCase() === currentQuestion.question.answer.toLowerCase()) {
      __success__ = true;
    } else if ($.inArray($(".dialog > paper-dialog > paper-input").val().toLowerCase(), __lower_array) !== -1) {
      __success__ = true;
    }
  }
  if (__success__) {
    console.log('%c right answer', 'color: #3BFF5F;');
    fight_attack(attack_name);
    return currentFight.switch_turn();
  } else {
    console.log('%c wrong answer', 'color: #FF2424;');
    notify("<span style='color: #E53935;'>Wrong answer! Your attack failed!<span>");
    return setTimeout(function() {
      return currentFight.switch_turn();
    }, 500);
  }
};

fight_enemy_attack = function() {
  var __attack, __random;
  console.log("running fight_enemy_attack");
  __random = random(0, currentFight.enemy_attacks.length);
  __attack = currentFight.enemy_attacks[__random];
  console.log("" + __attack + " (" + __random + ")");
  fight_attack(__attack);
  return currentFight.switch_turn();
};

fight_attack = function(attack_name) {
  currAttack = data.attacks[attack_name];
  fight_change_vals(currAttack.action, currentFight.turn, currentFight.victim);
  if (currAttack.hasOwnProperty("action-self")) {
    fight_change_vals(currAttack['action-self'], currentFight.victim, currentFight.turn);
  }
  if (currentFight.turn === 'player') {
    notify(fight_parse_inline_vars(currAttack.text));
  } else if (currentFight.turn === 'enemy') {
    swal(fight_parse_inline_vars(currAttack.text));
    notify(fight_parse_inline_vars(currAttack.text));
  } else {
    console.log("No fight has been start yet or currentFight.turn is wrong: " + currentFight.turn);
  }
  return currentFight.check_health();
};

fight_change_vals = function(action, attacker, victim) {
  console.log("running fight_change_vals");
  if (currAttack.action[0] === 'hp') {
    currentFight[victim + '_health'] += Math.round(parseInt(action[1]) * currentFight[attacker + '_attack_multiplier'] * currentFight[victim + '_defense_multiplier'] * currentFight[attacker + '_lvl'] / 33);
    return currentFight.update_health();
  } else if (currAttack.action[0] === 'attack') {
    return currentFight[victim + "_attack_multiplier"] += action[1];
  } else if (currAttack.action[0] === 'defense') {
    return currentFight[victim + "_attack_multiplier"] += action[1];
  } else {
    console.log("++++++++++ERROR++++++++++");
    console.log("There's an error with the action[0]. currAttack is:");
    console.log(currAttack);
    console.log("action[0] is:");
    console.log(currAttack.action[0]);
    return console.log("++++++++++ERROR++++++++++");
  }
};

fight_attack_tooltip = function(self, other, dat, i) {
  var result;
  result = "";
  if (other && parseFloat(dat.other_val) !== 0 && parseFloat(dat.other_val) > 0 && dat.other_type.toLowerCase() === 'hp') {
    result += '<p><b>Enemy: </b>' + dat.other_type.toUpperCase() + ' +' + Math.round(dat.other_val * currentFight.player_attack_multiplier * currentFight.enemy_defense_multiplier * currentFight.player_lvl / 33) + '</p>';
  } else if (other && parseFloat(dat.other_val) !== 0 && parseFloat(dat.other_val) < 0 && dat.other_type.toLowerCase() === 'hp') {
    result += '<p><b>Enemy: </b>' + dat.other_type.toUpperCase() + ' ' + Math.round(dat.other_val * currentFight.player_attack_multiplier * currentFight.enemy_defense_multiplier * currentFight.player_lvl / 33) + '</p>';
  } else if (other && parseFloat(dat.other_val) !== 0 && parseFloat(dat.other_val) > 0 && dat.other_type.toLowerCase() === 'attack') {
    result += '<p><b>Enemy: </b>' + dat.other_type.toUpperCase() + ' +' + dat.other_val * 100 + '%</p>';
  } else if (other && parseFloat(dat.other_val) !== 0 && parseFloat(dat.other_val) < 0 && dat.other_type.toLowerCase() === 'attack') {
    result += '<p><b>Enemy: </b>' + dat.other_type.toUpperCase() + ' ' + dat.other_val * 100 + '%</p>';
  } else if (other && parseFloat(dat.other_val) !== 0 && parseFloat(dat.other_val) < 0 && dat.other_type.toLowerCase() === 'defense') {
    result += '<p><b>Enemy: </b>' + dat.other_type.toUpperCase() + ' +' + dat.other_val * (-100) + '%</p>';
  } else if (other && parseFloat(dat.other_val) !== 0 && parseFloat(dat.other_val) > 0 && dat.other_type.toLowerCase() === 'defense') {
    result += '<p><b>Enemy: </b>' + dat.other_type.toUpperCase() + ' ' + dat.other_val * (-100) + '%</p>';
  }
  console.log(self);
  console.log(dat.self_type);
  console.log(dat.self_val);
  if (self && parseFloat(dat.self_val) !== 0 && parseFloat(dat.self_val) > 0 && dat.self_type.toLowerCase() === 'hp') {
    result += '<p><b>You: </b>' + dat.self_type.toUpperCase() + ' +' + Math.round(dat.self_val * currentFight.player_attack_multiplier * currentFight.enemy_defense_multiplier * currentFight.player_lvl / 33) + '</p>';
  } else if (self && parseFloat(dat.self_val) !== 0 && parseFloat(dat.self_val) < 0 && dat.self_type.toLowerCase() === 'hp') {
    result += '<p><b>You: </b>' + dat.self_type.toUpperCase() + ' ' + Math.round(dat.self_val * currentFight.player_attack_multiplier * currentFight.enemy_defense_multiplier * currentFight.player_lvl / 33) + '</p>';
  } else if (self && parseFloat(dat.self_val) !== 0 && parseFloat(dat.self_val) > 0 && dat.self_type.toLowerCase() === 'attack') {
    result += '<p><b>You: </b>' + dat.self_type.toUpperCase() + ' +' + dat.self_val * 100 + '%</p>';
  } else if (self && parseFloat(dat.self_val) !== 0 && parseFloat(dat.self_val) < 0 && dat.self_type.toLowerCase() === 'attack') {
    result += '<p><b>You: </b>' + dat.self_type.toUpperCase() + ' ' + dat.self_val * 100 + '%</p>';
  } else if (self && parseFloat(dat.self_val) !== 0 && parseFloat(dat.self_val) > 0 && dat.self_type.toLowerCase() === 'defense') {
    result += '<p><b>You: </b>' + dat.self_type.toUpperCase() + ' ' + dat.self_val * (-100) + '%</p>';
  } else if (self && parseFloat(dat.self_val) !== 0 && parseFloat(dat.self_val) < 0 && dat.self_type.toLowerCase() === 'defense') {
    result += '<p><b>You: </b>' + dat.self_type.toUpperCase() + ' +' + dat.self_val * (-100) + '%</p>';
  }
  if (result === '') {
    result = 'Nothing happens';
  }
  return $('.select_attack > .attack_btns > .' + i + ' > .tip').html(result);
};

fight_parse_inline_vars = function(text) {
  var i, __attacker, __res, __victim, _i, _ref;
  console.log("running fight_parse_inline_vars");
  __attacker = currentFight.character;
  __victim = currentFight.enemy;
  if (currentFight.turn === 'enemy') {
    __attacker = currentFight.enemy;
    __victim = currentFight.character;
  }
  __res = text.split("||");
  for (i = _i = 0, _ref = __res.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
    if (__res[i].toLowerCase() === 'creature') {
      __res[i] = __attacker;
    } else if (__res[i].toLowerCase() === 'enemy') {
      __res[i] = __victim;
    }
  }
  return __res = __res.join("");
};

check_for_new_game = function() {
  if (localStorage.character === void 0 || localStorage.name === null) {
    localStorage.ownedCreatures = '';
    localStorage.money = 0;
    $("#dialog_choose_name")[0].toggle();
    return console.log("toggling dialog");
  } else {
    return load_story();
  }
};

skip_tut = function() {
  if (parseInt(localStorage.story_pos) === 0 && localStorage.finished_tut === "true") {
    if (localStorage.storyline === "latin") {
      return localStorage.story_pos = 10;
    }
  }
};

parse_story = function() {
  console.log("running parse_story");
  if (parseInt(localStorage.story_pos) >= data.story.length) {
    $(".dialog").html("<paper-dialog backdrop autoCloseDisabled='true' heading='Which story do you want to play next?' class='paper-dialog-transition paper-dialog-transition-bottom' transition='paper-dialog-transition-bottom'> <h3>Choose one of the three. You will still learn the same language and have the same creature, but your level will be reset. You can also replay the story you just played. Or you can completely reset the game and choose another language to learn.</h3> <paper-button onclick=\"set_storyline('english');\" raised role='button' affirmative>English</paper-button> <paper-button onclick=\"set_storyline('latin');\" raised  role='button' affirmative>Latin</paper-button> <paper-button onclick=\"set_storyline('french');\" raised  role='button' affirmative>French</paper-button> <paper-button onclick=\"reset();\" raised role='button' affirmative>Reset</paper-button> </paper-dialog>");
    $(".dialog > paper-dialog")[0].toggle();
    return;
  }
  skip_tut();
  return parse_story_element(data.story[parseInt(localStorage.story_pos)]);
};

parse_story_element = function(element) {
  var __swal;
  console.log(element);
  if (element.type === "text") {
    notify(parse_inline_vars(element.value));
    return setTimeout(function() {
      localStorage.story_pos = parseInt(localStorage.story_pos) + 1;
      return parse_story();
    }, 1000);
  } else if (element.type === "pop") {
    console.log('poping');
    return setTimeout(function() {
      if (element.hasOwnProperty("title")) {
        console.log('has title');
        return swal({
          text: parse_inline_vars(element.value),
          title: parse_inline_vars(element.title)
        }, function() {
          return setTimeout(function() {
            localStorage.story_pos = parseInt(localStorage.story_pos) + 1;
            parse_story();
            return console.log("callback from swal");
          }, 250);
        });
      } else {
        return swal({
          title: parse_inline_vars(element.value)
        }, function() {
          return setTimeout(function() {
            localStorage.story_pos = parseInt(localStorage.story_pos) + 1;
            parse_story();
            return console.log("callback from swal");
          }, 250);
        });
      }
    }, 250);
  } else if (element.type === "advanced_pop") {
    __swal = element.swal;
    if (__swal.hasOwnProperty("title")) {
      __swal.title = parse_inline_vars(__swal.title);
    }
    if (__swal.hasOwnProperty("text")) {
      __swal.text = parse_inline_vars(__swal.text);
    }
    if (__swal.hasOwnProperty("confirmButtonText")) {
      __swal.confirmButtonText = parse_inline_vars(__swal.confirmButtonText);
    }
    if (__swal.hasOwnProperty("cancelButtonText")) {
      __swal.cancelButtonText = parse_inline_vars(__swal.cancelButtonText);
    }
    if (element.hasOwnProperty("callback")) {
      return swal(__swal, callbacks[element.callback]);
    } else {
      return swal(__swal, function() {
        localStorage.story_pos = parseInt(localStorage.story_pos) + 1;
        return parse_story();
      });
    }
  } else if (element.type === 'fight') {
    console.log("fight lvl: " + element.lvl + " against " + element.enemy);
    return fight_start(element.enemy, parseInt(element.lvl));
  } else if (element.type === 'money') {
    add_money(element.amount);
    console.log("adding " + element.amount + " to your balance.");
    localStorage.story_pos = parseInt(localStorage.story_pos) + 1;
    return parse_story();
  }
};

parse_inline_vars = function(input) {
  var i, __print, _i, _ref;
  __print = input.split("||");
  for (i = _i = 0, _ref = __print.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
    if (__print[i].toLowerCase() === "name") {
      __print[i] = localStorage.name;
    } else if (__print[i].toLowerCase() === "creature") {
      __print[i] = localStorage.character;
    }
  }
  return __print = __print.join("");
};

reset = function() {
  return swal({
    title: "Are you sure?",
    text: "All progress will be lost.",
    type: "warning",
    showCancelButton: true,
    confirmButtonColor: "#DD6B55",
    confirmButtonText: "Yes, reset the game!",
    cancelButtonText: "No, cancel please!"
  }, function(confirmed) {
    if (confirmed) {
      localStorage.clear();
      return location.reload();
    } else {
      return location.reload();
    }
  });
};

set_name = function() {
  console.log("Name set: " + ($("#dialog_choose_name > paper-input").val()));
  localStorage.name = $("#dialog_choose_name > paper-input").val();
  $("#dialog_choose_name").remove();
  $("#dialog_backstory").attr("heading", "Welcome to the Hugo Science Enrichment Center");
  $("#dialog_backstory").html("<p>HugoOS: We here at Hugo Science Enrichment Center are the leading scientists in terms of portals and time travel. You have been chosen to test our newest time machine protoype. You may never come back, so choose wisely if you want to go to ancient Rome, the England of Shakepeare or the french revolution.</p> <paper-button onclick='show_choose_creature()' affirmative autofocus role='button'>Got it</paper-button>");
  return $("#dialog_backstory")[0].toggle();
};

set_character = function(what) {
  add_creature(what);
  localStorage.character = what;
  localStorage.lvl = 1;
  localStorage.finished_tut = false;
  localStorage.story_pos = 0;
  $("#dialog_choose_creature").remove();
  return $(".core-overlay-backdrop").remove();
};

set_storyline = function(which) {
  console.log("Running set_storyline");
  localStorage.story_pos = 0;
  localStorage.lvl = 1;
  localStorage.storyline = which;
  $(".core-overlay-backdrop").remove();
  return load_story();
};

show_choose_creature = function() {
  $("#dialog_backstory").remove();
  $("#dialog_choose_creature")[0].toggle();
  return notify("HugoOS: We here at Hugo Science Enrichment Center are the leading scientists in terms of portals and time travel. You have been chosen to test our newest time machine protoype. You may never come back, so choose wisely if you want to go to ancient Rome, the England of Shakepeare or the french revolution.");
};

notify = function(text) {
  $("#timeline_content").prepend("<p class='notification-element'>" + text + "</p>");
  $(".notification-element:nth-of-type(1)").css("display", "none");
  return $(".notification-element:nth-of-type(1)").fadeIn("fast");
};

pop = function(text, heading) {
  return $(".dialog").html('<paper-dialog heading="' + heading + '" opened="true" transition="paper-dialog-transition-bottom">' + text + '</paper-dialog>');
};

init = function() {
  check_for_new_game();
  emojify.setConfig({
    img_dir: 'bower_components/emojify/images/emoji'
  });
  emojify.run();
  return update_money();
};
